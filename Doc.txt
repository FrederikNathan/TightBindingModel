Documentation

The main module is tightbinding model. This contains the object representing tight-binding models (TBM.Hamiltonian), as well as general methods for these. It also contains definition objects that live in the Brillouin zone more generally (such as band structure, and general n x m-dimensional fields). 

2nd module is called lattice model. It translates a tight binding Hamiltonian to a lattice Hamiltonian matrix, with given dimensionality and boundary conditions. Also contains useful objects and methods when working with lattice models, such as disorder.

3rd module is called BasicFunctions. It contains basic, useful functions such as logging etc. 


TightBindingModel

To run:
Any tight-binding model is defined with a dimensionality, and orbital dimension. When using TightBindingModel (TBM), one should define the following, before calling any object or function:

TBM.Dimension = D
TBM.OrbitalDimension = X

where D is the physical dimension of the model, and X denotes the number of orbitals per unit cell. 




BZO (Brillouin Zone Object): 
Fundamental object used to represent fields defined on a Brillouin zone. In particular, Hamiltonians are a subclass of a BZO. The BZO object stores the information of the field in a compact way, which enables fast execution of common methods.

Since a field on the BZ is a periodic function of crystal momentum, it can be decomposed into discrete harmonics (a Fourier series): F(k) = \sum_{abc} F_{abc} e^{-i (aq_1 +bq_2 + cq_3) \cdot k}. For example Hamiltonians have particularly simple harmonics, since the (i,j,k)th Harmonic corresponds to hopping between unit cells separated by vector  (ia_1,ja_2 ,ka_3), where  a_i denotes the ith basis vector of the lattice (normally only nearest-neighbour hopping is allowed, and hence only the 9 components  (\pm 1, \pm 1 , \pm 1), (0,0,0) are nonzero.  

In essence, the BZO represents a BZ field by storing a list of components $\{F_1 , \ldots F_n\}$ (ObjList), along with their corresponding indices {(a_1,b_1,c_1),\ldots (a_n,b_n,c_n)} (IndList). 

Defining a BZO:
A BZO can be defined in 3 different ways

Method 1: the BZO can be generated from an IndList and ObjList generated previously:

A = <IndList>
B = <ObjList>
X = BZO(A,B[,dtype = d])

Method 2: the BZO from an (m_1 x ... m_n) array of BZO's 

A=<BZO_1>
B=<BZO_2>
C=array([A,B])

X=BZO(C[,dtype=d])

Method 3: the BZO is defined as an empty object, and harmonics can be set afterwards. Here the shape should be specified. 

X=BZO(shape=(2,2),dtype=float)
X[1,2,3]=array([[1,2],[3,4]])


Methods
The (i,j,k)th of a BZO object A can be accessed and set by calling A[i,j,k] (also generalizes to more dimensions). 






    
    The BZO field saves the object through its Fourier components (saved in ObjList),
    with the corresponding "wavevector" saved in IndList. 
   
    All standard operations, as well as scalar addition are defined for BZO's.
    This included multiplication and addition of two BZOs (resulting in a third 
    BZO)
    
    When BZO is called at a crystal momentum, or an array or list of crystal momenta,
    an array is returned with the values of the field at the k-points listed in the array. 
    10 x  efficiency can be achieved when calling the BZO function with the vector span-format (see __call__).
    
    When list element is referred to, returns corresponding harmonic, such that BZO[n,m,k] returns the 
    (n,m,k)th Fourier Harmonic """
       
    
    """Also contains numlist, which sorts the indices, and is used for rapidly finding elements in 
    indlist and objlist. In this list, indices ind IndList are translated to integers, using
    the __IndexCounter variable. __IndexCounter is not fixed, but is by default set to 1e6.
    Elements in IndList and ObjList are sorted according to their values in NumList. """
    
    
    """ If list element (a,b) is empty, F[a,b] returns BZO.__ZeroObject. This object acts as the 
    zero matrix in all ways, except that a new object and index is added to the IndList and ObjList, if 
    F[a,b] is set to a nonzero value. 
    I.e. 
    
    print(4*F[a,b]) returns  [[0,0]
                            [0,0]]
    
    But if we set F[a,b] = X
    
    (a,b) is added to indlist, with corresponding ObjList element giben by  x
    such that 
    
    F[a,b]=x