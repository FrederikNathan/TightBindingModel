{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28640\viewh21200\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Documentation\
\

\b0 The main module is tightbinding model. This contains the object representing tight-binding models (TBM.Hamiltonian), as well as general methods for these. It also contains definition objects that live in the Brillouin zone more generally (such as band structure, and general n x m-dimensional fields). \
\
2nd module is called lattice model. It translates a tight binding Hamiltonian to a lattice Hamiltonian matrix, with given dimensionality and boundary conditions. Also contains useful objects and methods when working with lattice models, such as disorder.\
\
3rd module is called BasicFunctions. It contains basic, useful functions such as logging etc. \
\
\

\b TightBindingModel\
\
To run:\

\b0 Any tight-binding model is defined with a dimensionality, and orbital dimension. When using TightBindingModel (TBM), one should define the following, before calling any object or function:\
\
TBM.Dimension = D\
TBM.OrbitalDimension = X\
\
where D is the physical dimension of the model, and X denotes the number of orbitals per unit cell. \
\
\

\b \
\
\ul BZO (
\b0 Brillouin Zone Object): \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \ulc0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \ulnone Syntax: BZO(*args,shape=None,dtype=complex) \ul \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \ulnone Fundamental object used to represent fields defined on a Brillouin zone. In particular, Hamiltonians are a subclass of a BZO. The BZO object stores the information of the field in a compact way, which enables fast execution of common methods.\
\
Since a field on the BZ is a periodic function of crystal momentum, it can be decomposed into discrete harmonics (a Fourier series): F(k) = \\sum_\{abc\} F_\{abc\} e^\{-i (aq_1 +bq_2 + cq_3) \\cdot k\}.For example Hamiltonians have particularly simple harmonics, since the (i,j,k)th Harmonic corresponds to hopping between unit cells separated by vector  (ia_1,ja_2 ,ka_3), where  a_i denotes the ith basis vector of the lattice (normally only nearest-neighbour hopping is allowed, and hence only the 9 components  (\\pm 1, \\pm 1 , \\pm 1), (0,0,0) are nonzero.  \
\
In essence, the BZO represents a BZ field by storing a list of components \{F_1 , \\ldots F_n\} (ObjList), along with their corresponding indices \{(a_1,b_1,c_1),\\ldots (a_n,b_n,c_n)\} (IndList). \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
The Harmonics \\\{F_\{ijk\}\\\} of a BZO can be accessed and set using the __set__ and __get__ method: \
\
BZO[i,j,k] =F_\{ijk\}. \
\
The value of F at a crystal momentum k (or a collection of crystal momenta) can be found using the __call__method (see __call__ method for how multiple k-points should be formatted): \
\
BZO(k) = F(k)\
\
Currently, TBM only works for square lattices: by default q_i  is the ith unit vector. In a future version, the BZO can be updated to allow for general vectors).\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \

\b Defining a BZO:
\b0 \
A BZO can be defined in 3 different ways\
\

\i Method 1: 
\i0 the BZO can be generated from an IndList and ObjList generated previously:\
\
A = <IndList>\
B = <ObjList>\
X = BZO(A,B)\
\

\i Method 2
\i0 : the BZO from an (m_1 x ... m_n) array of BZO's \
\
A=<BZO_1>\
B=<BZO_2>\
C=array([A,B])\
\
X=BZO(C)\
\

\i Method 3: 
\i0 the BZO is defined as an empty object, and harmonics can be set afterwards. Here the shape should be specified (in the other two cases it should remain \'93None\'94). \
\
X=BZO(shape=(2,2),dtype=float)\
X[1,2,3]=array([[1,2],[3,4]])\
\

\b Basic Methods\

\b0 \

\i Set and Get 
\i0 \
The (i,j,k)th of a BZO object A can be accessed and set by calling A[i,j,k] (also generalizes to more dimensions). If BZO A is initially empty, \
\
print(A[i,j,k]) returns 0\
\
However, A[i,j,k] =4; print(A[i,j,k]); returns  4. \
\
One can also use (with a 2x2 field, for example) A[i,j,k][1,0] = x, even when the i,j,kth harmonic is initially zero. In this case, print(A[i,j,k]) returns array([[0,0],[x,0]]).\
\

\i Call\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\i0 \cf0 The value of a BZO can be evaluated at crystal momentum k, or at an array of crystal momenta Karray by calling the BZO.\
For a single k, BZO(k) returns F(k) = \\sum_\{abc\} F_\{abc\} e^\{-i (aq_1 +bq_2 + cq_3) \\cdot k\}.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 For an (m_1 x \'85 m_n) array crystal momenta K, BZO(K) returns a (m_1 x \'85 m_n) array of the corresponding values of BZO(K).\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 If a large number of crystal momenta need to be probed, A 10-fold increase in efficiency can be achieved when calling the BZO function with the vector span-format. Here, for kvec_i being a d_i-length vector\
\
BZO(kvec_1,kvec_2, \'85kvec_n)\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
returns an array of shape (d_1 \'85 d_n) with the k-points contained in  the direct product of the vectors \{kvec_n\}. \
\

\i Algebraic methods
\i0 \
Multiplication, addition and subtraction are defined between BZOs of the same shape. Here the operation returns the corresponding BZO. I.e., if A and B are the BZO representing the BZ field F(k) and G(k), A*B represents F(k)*G(k). The product of two BZOs is computed efficiently from IndList and ObjList. \
\
Moreover, scalar multiplication and division are defined. In Hamiltonian and Scalar subclasses, a scalar Scalar addition are also defined. \
\

\b Advanced methods:\

\b0 \

\i NNZ()\

\i0 Returns number of nonzero harmonics (i.e. len(IndList)). \
\

\i ObjList()
\i0 \
Returns ObjList (ie.. sorted list with Harmonics)\
\

\i IndList()\

\i0 Returns IndList (i.e. sorted list with planewaves corresponding to harmonics)\
\
\
\
\
\
\
    \
    The BZO field saves the object through its Fourier components (saved in ObjList),\
    with the corresponding "wavevector" saved in IndList. \
   \
    All standard operations, as well as scalar addition are defined for BZO's.\
    This included multiplication and addition of two BZOs (resulting in a third \
    BZO)\
    \
    When BZO is called at a crystal momentum, or an array or list of crystal momenta,\
    an array is returned with the values of the field at the k-points listed in the array. \
    \
    When list element is referred to, returns corresponding harmonic, such that BZO[n,m,k] returns the \
    (n,m,k)th Fourier Harmonic """\
       \
    \
    """Also contains numlist, which sorts the indices, and is used for rapidly finding elements in \
    indlist and objlist. In this list, indices ind IndList are translated to integers, using\
    the __IndexCounter variable. __IndexCounter is not fixed, but is by default set to 1e6.\
    Elements in IndList and ObjList are sorted according to their values in NumList. """\
    \
    \
    """ If list element (a,b) is empty, F[a,b] returns BZO.__ZeroObject. This object acts as the \
    zero matrix in all ways, except that a new object and index is added to the IndList and ObjList, if \
    F[a,b] is set to a nonzero value. \
    I.e. \
    \
    print(4*F[a,b]) returns  [[0,0]\
                            [0,0]]\
    \
    But if we set F[a,b] = X\
    \
    (a,b) is added to indlist, with corresponding ObjList element giben by  x\
    such that \
    \
    F[a,b]=x}